{
  "hash": "95f40cf24b940c5168901795925afeec",
  "result": {
    "engine": "knitr",
    "markdown": "# Generalized Linear Models\n\n\n\n\n\n\n\\def\\cd{\\cdot}\n\\def\\eqdef{\\stackrel{\\text{def}}{=}}\n\\def\\defeq{\\stackrel{\\text{def}}{=}}\n\\def\\hb{\\hat\\beta}\n\\def\\za{z_{1 - \\frac{\\alpha}{2}}}\n\\def\\cirad{\\za \\cd \\hse{\\hb}}\n\\def\\ci{\\hb {\\color{red}\\pm} \\cirad}\n\\def\\th{\\theta}\n\\def\\hth{\\hat\\theta}\n\\def\\ba{\\begin{aligned}}\n\\def\\ea{\\end{aligned}}\n\\def\\e{\\epsilon}\n\\def\\om{\\omega}\n\\providecommand{\\red}[1]{{\\color{red}#1}}\n\\providecommand{\\blue}[1]{{\\color{blue}#1}}\n\\providecommand{\\green}[1]{{\\color{green}#1}}\n\\providecommand{\\cbl}[1]{\\left\\{#1\\right.}\n\\providecommand{\\cb}[1]{\\left\\{#1\\right\\}}\n\\providecommand{\\paren}[1]{\\left(#1\\right)}\n\\providecommand{\\hE}[1]{\\hat{\\text{E}}\\left[#1\\right]}\n\n\\providecommand{\\E}[1]{\\mathbb{E}\\left[#1\\right]}\n\\providecommand{\\var}[1]{\\text{Var}\\left(#1\\right)}\n\\providecommand{\\Var}[1]{\\text{Var}\\left(#1\\right)}\n\\providecommand{\\varh}[1]{\\hat{\\text{Var}}\\left(#1\\right)}\n\\providecommand{\\vc}[1]{\\boldsymbol{#1}}\n\\providecommand{\\se}[1]{\\text{se}\\left(#1\\right)}\n\\providecommand{\\hse}[1]{\\hat{\\text{se}}\\left(#1\\right)}\n\\providecommand{\\SE}[1]{\\text{SE}\\left(#1\\right)}\n\\renewcommand{\\log}[1]{\\text{log}\\cb{#1}}\n\\renewcommand{\\exp}[1]{\\text{exp}\\cb{#1}}\n\\providecommand{\\e}[1]{\\text{e}^{#1}}\n\\providecommand{\\inv}[1]{\\left(#1\\right)^{-1}}\n\\providecommand{\\ind}[1]{\\mathbb{1}_{#1}}\n\\providecommand{\\pr}{\\text{p}}\n\\providecommand{\\Bias}[1]{\\text{Bias}\\left(#1\\right)}\n\\providecommand{\\bias}[1]{\\text{Bias}\\left(#1\\right)}\n\\providecommand{\\ssqf}[1]{\\sigma^2\\left(#1\\right)}\n\\providecommand{\\mselr}[1]{\\text{MSE}\\left(#1\\right)}\n\\providecommand{\\maelr}[1]{\\text{MAE}\\left(#1\\right)}\n\\providecommand{\\abs}[1]{\\left|#1\\right|}\n\\providecommand{\\sqf}[1]{\\left(#1\\right)^2}\n\\providecommand{\\sq}{^2}\n\n\n\n\n\n\nThis section is primarily adapted starting from the textbook \"An Introduction to Generalized Linear Models\" (4th edition, 2018)\nby Annette J. Dobson and Adrian G. Barnett:\n\n<https://doi.org/10.1201/9781315182780>\n\nThe type of predictive model one uses depends on several issues; one is the type of response.\n\n* Measured values such as quantity of a protein, age, weight usually can be handled in an ordinary linear regression model, possibly after a log transformation.\n\n* Patient survival, which may be censored, calls for a different method (survival analysis, Cox regression).\n\n* If the response is binary, then can we use logistic regression models\n\n* If the response is a count, we can use Poisson regression\n\n* If the count has a higher variance than is consistent with the Poisson, we can use a negative binomial or over-dispersed Poisson\n\n* Other forms of response can generate other types of generalized linear models\n\nWe need a linear predictor of the same form as in linear regression βx. In theory, such a linear predictor can generate any type of number as a prediction, positive, negative, or zero\n\nWe choose a suitable distribution for the type of data we are predicting (normal for any number, gamma for positive numbers, binomial for binary responses, Poisson for counts)\n\nWe create a link function which maps the mean of the distribution onto the set of all possible linear prediction results, which is the whole real line (-∞, ∞). The inverse of the link function takes the linear predictor to the actual prediction.\n\n* Ordinary linear regression has identity link (no transformation by the link function) and uses the normal distribution\n\n* If one is predicting an inherently positive quantity, one may want to use the log link since ex is always positive.\n\n* An alternative to using a generalized linear model with a log link, is to transform the data using the log. This is a device that works well with measurement data and may be usable in other cases, but it cannot be used for 0/1 data or for count data that may be 0.\n\nFamily | Links\n------ | ------ \ngaussian | **identity**, log, inverse\nbinomial | **logit**, probit, cauchit, log, cloglog\ngamma | **inverse**, identity, log\ninverse.gaussian | **1/mu^2**, inverse, identity, log\nPoisson | **log**, identity, sqrt\nquasi | **identity**, logit, probit, cloglog, inverse, log, 1/mu^2 and sqrt\nquasibinomial | **logit**, probit, identity, cloglog, inverse, log, 1/mu^2 and sqrt\nquasipoisson | **log**, identity, logit, probit, cloglog, inverse, 1/mu^2 and sqrt\n\n: R glm() Families\n\nName | Domain | Range | Link Function | Inverse Link Function\n------| ------ | ----- | ----- | ------\nidentity | $(-\\infty, \\infty)$ | $(-\\infty, \\infty)$ | $\\eta = \\mu$ | $\\mu = \\eta$\nlog | $(0,\\infty)$ | $(-\\infty, \\infty)$ | $\\eta = \\log{\\mu}$ | $\\mu = \\exp{\\eta}$\ninverse | $(0, \\infty)$ | $(0,\\infty)$ | $\\eta = 1/\\mu$ | $\\mu = 1/\\eta$\nlogit | $(0,1)$ | $(-\\infty, \\infty)$ | $\\eta = \\log{\\mu/(1-\\mu)}$ | $\\mu = \\exp{\\eta}/(1+\\exp{\\eta})$\nprobit | $(0,1)$ | $(-\\infty, \\infty)$ | $\\eta = \\Phi^{-1}(\\mu)$ | $\\mu = \\Phi(\\eta)$\ncloglog | $(0,1)$ | $(-\\infty, \\infty)$ | $\\eta = \\log{-\\log{1-\\mu}}$ | $\\mu = {1-\\exp{-\\exp{\\eta}}}$\n1/mu^2 | $(0,\\infty)$ | $(0, \\infty)$ | $\\eta = 1/\\mu^2$ | $\\mu = 1/\\sqrt{\\eta}$\nsqrt | $(0,\\infty)$ | $(0,\\infty)$ | $\\eta = \\sqrt{\\mu}$ | $\\mu = \\eta^2$\n\n\n: R `glm()` Link Functions; $\\eta = X\\beta = g(\\mu)$\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}